Workfront API Context

Core Objects:
TASK: Represents individual tasks.
PROJ: Represents projects.
USER: Represents users (people in the org).

You can specify filters to retrieve objects by specific criteria. The "filters" property should be a list of key-value pairs where the key is a field name and the value is the filter value, e.g. {"name":"My Project"}
You can enhance a search for objects using modifiers. Modifiers allow you to search for values less than, greater than, between, not equal, etc.
When adding a modifier, add a filter key with the field name and append "_Mod", e.g. {"name_Mod": "cicontains"}.

Here are the possible modifiers you can use:
- lt: field < value
- lte: field <= value
- gt: field > value
- gte: field >= value
- eq: field = value
- cieq: UPPER(field) = UPPER(value)
- ne: field <> value or field is null
- nee: field <> value (null results not returned)
- cine: UPPER(field) <> UPPER(value)
- contains: field LIKE '%value%'
- cicontains: UPPER(field) LIKE UPPER('%value%')
- cicontainsany: UPPER(field) LIKE UPPER('%value1%') OR UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cicontainsall: UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cinotcontainsall: UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cinotcontainsany: UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- notcontains: field NOT LIKE '%value%'
- cinotcontains: UPPER(field) NOT LIKE UPPER('%value%')
- like: field LIKE 'value' where value can contain replacement characters such as % and _
- cilike: UPPER(field) LIKE UPPER('value') where value can contain replacement characters such as % and _
- likeescape: field LIKE 'value' ESCAPE '_' where value can contain replacement character %, the underscore character _ evaluates as an escaped character
- cilikeescape: UPPER(field) LIKE UPPER('value') ESCAPE '_' where value can contain replacement character %, the underscore character _ evaluates as an escaped character
- startswith: UPPER(field) LIKE UPPER('value%')
- between: field BETWEEN {fieldname:value} AND {fieldname_Range:value}
- cibetween: UPPER(field) BETWEEN UPPER(value) AND UPPER(value_Range)
- notbetween: field NOT BETWEEN value AND value_Range
- cinotbetween: UPPER(field) NOT BETWEEN UPPER(value) AND UPPER(value_Range)
- in: field IN (value1, value2, ..., valuen) (default when multiple value fields exist)
- ciin: UPPER(field) IN (UPPER(value1), UPPER(value2), ..., UPPER(valuen))
- notin: field NOT IN (value1, value2, ..., valuen)
- cinotin: UPPER(field) NOT IN (UPPER(value1), UPPER(value2), ..., UPPER(valuen))
- exacttime: field = value (enforces exact time match for date searches)
- isnull: field IS NULL
- notnull: field IS NOT NULL
- isblank: field IS NULL OR field = ''
- notblank: field IS NOT NULL AND field <> ''

Can also use $$TODAY keyword in a query. Here are some examples and explanation: 

Wildcard value for midnight (12:00AM) of the current Date. Wildcards are useful for Saved Searches. If this value is passed in for any search value, it is replaced with the current date.
The following suffixes can also be used to modify this date: [b/e][+/-][# of units]["h" (hour)|"d" (day)|"w" (week)|"m" (month)|"q" (quarter)|"y" (year)]

Examples:
$$TODAY+1d would equal 12:00AM of the next day
$$TODAY-1d would equal 12:00AM of the previous day
$$TODAY+2w would equal 12:00AM of 2 weeks from today
$$TODAY+2m would equal 12:00AM of 2 months from today
$$TODAYb "the beginning of today" would equal 12:00AM today
$$TODAYe "the end of today" would equal 12:00AM tomorrow
$$TODAYbm "the beginning of the month" would equal 12:00AM of the first day of the month
$$TODAYe+1w "the end of next week" would equal 12:00AM Sunday following the Saturday of next week

