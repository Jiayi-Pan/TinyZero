Workfront API Context


 Workfront Object Context You Can Use

 Core Objects:
TASK: Represents individual tasks.
PROJ: Represents projects.
USER: Represents users (people in the org).

--- PROJECT METADATA ---
domain_knowledge:|
  Projects represent the main container of work that is to be completed. A Project may contain many different tasks or issues. Projects have both a plannedCompletionDate 
  which represents an estimate or planned completion date, and also a actualCompletionDate which represents the actual completion date of the project. If you are looking
  for when things actually completed use the actualCompletionDate, if you are wanting to know when something is planned to be completed use the plannedCompletionDate.
  Default Statuses include: Current, Dead, On Hold, Planning, Complete, Requested, Approved, Rejected, and Idea

  PROJ_FIELDS = [
    "actualCompletionDate",
    "actualCost",
    "actualDurationExpression",
    "actualDurationMinutes",
    "actualHoursLastMonth",
    "actualHoursLastThreeMonths",
    "actualHoursThisMonth",
    "actualHoursTwoMonthsAgo",
    "actualStartDate",
    "actualValue",
    "actualWorkRequired",
    "actualWorkRequiredDouble",
    "actualWorkRequiredExpression",
    "approvalCompletionDate",
    "approvalEstStartDate",
    "approvalProcessID",
    "approvalProjectedStartDate",
    "approvalStartDate",
    "approversString",
    "budgetedStartDate",
    "budgetStatus",
    "categoryID",
    "companyID",
    "companyRatesOverride",
    "completedHours",
    "completedStoryPoints",
    "completionType",
    "condition",
    "conditionType",
    "currency",
    "customerID",,
    "description",
    "durationExpression",
    "durationMinutes",
    "enteredByID",
    "entryDate",
    "fixedStartDate",
    "groupID",
    "hasCompletionConstraint",
    "hasDocuments",
    "ID",
    "isOriginalPlannedHoursSet",
    "isProjectDead",
    "isStatusComplete",
    "lastCalcDate",
    "lastConditionNoteID",
    "lastNoteID",
    "lastUpdateDate",
    "lastUpdatedByID",
    "name",
    "numberOfOpenRisks",
    "numberOpenOpTasks",
    "originalWorkRequired",
    "ownerID",
    "pendingCalculation",
    "percentComplete",
    "personal",
    "plannedCompletionDate",
    "plannedDateAlignment",
    "plannedHoursAlignment",
    "plannedStartDate",
    "plannedValue",
    "portfolioID",
    "portfolioPriority",
    "priority",
    "programID",
    "progressStatus",
    "projectBudgetedCost",
    "projectedCompletionDate",
    "projectedStartDate",,
    "referenceNumber",
    "risk",
    "scheduleID",
    "showCondition",
    "showStatus",
    "sponsorID",
    "status",
    "statusLabel",
    "statusUpdate",
    "storiesWithoutPoints",
    "storyPointsPercentComplete",
    "submittedByID",
    "teamID",
    "templateID",
    "totalHours",
    "totalOpTaskCount",
    "totalStoryPoints",
    "totalTaskCount",
    "updateType",
    "URL",
    "version",
]



--- TASK METADATA ---
domain_knowledge: |
  Tasks always belong to a project, so they always have the field projectID even when updating a task or making an assignment. 
  To update existing tasks, you must include the taskID in the request. 
  Tasks may also have subtasks, in which case they have a parent task (parentID) and a projectID.
  Tasks frequently have an assignment to a user, team, or role.
  Tasks can have both a plannedCompletionDate and a actualCompletionDate - if you want to know the actual date something was completed, use actualCompletionDate.
  Assignments can be added when creating an task by adding appropriate ids to the assignments array.
  A task name is always required.
  To set a Due Date, set the taskConstraint to MFO and the constraintDate to the desired date.  
  To set a Start Date, set the taskConstraint to MSO and the constraintDate to the desired date.
  Default statuses include: New, In Progress, and Complete
  Tasks include a taskNumber.  The task number shows the order the task appears in a list as shown to the user.  The user may referer to a task by its task number instead of its name.
  If a user refers to a task by its number insetead of its name, then it will need to be search by taskNumber instead of name to find the task id.  i.e. I want to rename task 3 to "New Task Name"

  TASK_FIELDS = [
    "accessorIDs",
    "actualCompletionDate",
    "actualDuration",
    "actualDurationMinutes",
    "actualStartDate",
    "actualWork",
    "actualWorkRequired",
    "approvalCompletionDate",
    "approvalEstStartDate",
    "approvalProcessID",
    "approvalProjectedStartDate",
    "approvalStartDate",
    "assignments",
    "assignedTo",
    "assignedToID",
    "assignmentsListString",
    "categoryID",
    "color",
    "commitDate",
    "commitDateRange",
    "completionPendingDate",
    "condition",
    "constraintDate",
    "costAmount",
    "costType",
    "currentApprovalStepID",
    "customerID",
    "description",
    "duration",
    "durationExpression",
    "durationMinutes",
    "durationType",
    "enteredByID",
    "entryDate",
    "estCompletionDate",
    "estimate",
    "estStartDate",
    "groupID",
    "hasCompletionConstraint",
    "hasDocuments",
    "hoursPerPoint",
    "ID",
    "isCritical",
    "isReady",
    "isStatusComplete",
    "isWorkRequiredLocked",
    "iterationID",
    "lastUpdateDate",
    "lastUpdatedByID",
    "milestoneID",
    "name",
    "numberOfChildren",
    "numberOpenOpTasks",
    "originalActualWorkRequired",
    "originalActualWorkRequiredDouble",
    "originalDuration",
    "originalWorkRequired",
    "parentID",
    "pendingCalculation",
    "pendingUpdateMethods",
    "percentComplete",
    "personal",
    "plannedCompletionDate",
    "plannedCompletionDateExpression",
    "plannedCost",
    "plannedDateAlignment",
    "plannedDuration",
    "plannedDurationMinutes",
    "plannedHoursAlignment",
    "plannedStartDate",
    "plannedStartDateExpression",
    "previousStatus",
    "priority",
    "progressStatus",
    "projectID",
    "referenceNumber",
]


--- USER METADATA ---

domain_knowledge: |
  When searching for a user by name, be sure to check firstName, lastName, and name fields.  
  Use the OR operator because the name may not appear in all three fields.  
  Searching by email or username may also be used.

  USER_FIELDS = [
    "accessLevelID",
    "accessLevelIDBackup",
    "address",
    "address2",
    "apiKeyCreateDate",
    "billingPerHour",
    "categoryID",
    "city",
    "companyID",
    "costPerHour",
    "country",
    "customerID",
    "customFormsDescriptions",
    "customFormsGroupIDs",
    "customFormsIDs",
    "customFormsNames",
    "defaultHourTypeID",
    "eauthUserID",
    "emailAddr",
    "enteredByID",
    "entryDate",
    "extRefID",
    "firstName",
    "hasAPIAccess",
    "hasDocuments",
    "hasNotes",
    "hasPassword",
    "homeGroupID",
    "homeTeamID",
    "ID",
    "isActive",
    "isAdmin",
    "lastEnteredNoteID",
    "lastLoginDate",
    "lastName",
    "lastNoteID",
    "lastProofApprovalSync",
    "lastUpdateDate",
    "lastUpdatedByID",
    "latestUpdateNoteID",
    "loginBlocked",
    "loginCount",
    "managerID",
    "mobilePhoneNumber",
    "myInfo",
    "name",
    "parentGroupIDs",
    "password",
    "passwordDate",
    "persona",
    "phoneExtension",
    "phoneNumber",
    "portalProfileID",
    "postalCode",
    "resourcePoolID",
    "roleID",
    "scheduledDeactivationDate",
    "scheduleID",
    "state",
    "statusUpdate",
    "teams",
    "teamsListString",
    "timesheetProfileID",
    "timeZone",
    "title",
    "username",
]

When make a search api call to workfront, fiters can be a list of key, value, the key could be a fieldname or a filename with operator expression.
Suffix for specifying expression operators on a field. Value is "_Mod"
Here are a description for the search operators:
- lt: Produces the SQL expression field < value
- lte: Produces the SQL expression field <= value
- gt: Produces the SQL expression field > value
- gte: Produces the SQL expression field >= value
- eq: Produces the SQL expression field = value (default when 1 value exists)
- cieq: Produces the SQL expression UPPER(field) = UPPER(value)
- ne: Produces the SQL expression field <> value or field is null
- nee: Produces the SQL expression field <> value (null results not returned)
- cine: Produces the SQL expression UPPER(field) <> UPPER(value)
- contains: Produces the SQL expression field LIKE '%value%'
- cicontains: Produces the SQL expression UPPER(field) LIKE UPPER('%value%')
- cicontainsany: Produces the SQL expression UPPER(field) LIKE UPPER('%value1%') OR UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cicontainsall: Produces the SQL expression UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cinotcontainsall: Produces the SQL expression UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- cinotcontainsany: Produces the SQL expression UPPER(field) LIKE UPPER('%value1%') AND UPPER(field) LIKE UPPER('%value2%') ... where value1, value2, etc. are the results of value.split(" ")
- notcontains: Produces the SQL expression field NOT LIKE '%value%'
- cinotcontains: Produces the SQL expression UPPER(field) NOT LIKE UPPER('%value%')
- like: Produces the SQL expression field LIKE 'value' where value can contain replacement characters such as % and _
- cilike: Produces the SQL expression UPPER(field) LIKE UPPER('value') where value can contain replacement characters such as % and _
- likeescape: Produces the SQL expression field LIKE 'value' ESCAPE '_' where value can contain replacement character %, the underscore character _ evaluates as an escaped character
- cilikeescape: Produces the SQL expression UPPER(field) LIKE UPPER('value') ESCAPE '_' where value can contain replacement character %, the underscore character _ evaluates as an escaped character
- startswith: Produces the SQL expression UPPER(field) LIKE UPPER('value%')
- soundex: Produces the SQL expression SOUNDEX(field) = SOUNDEX(value)
- between: Produces the SQL expression field BETWEEN value AND value_Range (default when _Range value exists)
- cibetween: Produces the SQL expression UPPER(field) BETWEEN UPPER(value) AND UPPER(value_Range)
- notbetween: Produces the SQL expression field NOT BETWEEN value AND value_Range
- cinotbetween: Produces the SQL expression UPPER(field) NOT BETWEEN UPPER(value) AND UPPER(value_Range)
- in: Produces the SQL expression field IN (value1, value2, ..., valuen) (default when multiple value fields exist)
- ciin: Produces the SQL expression UPPER(field) IN (UPPER(value1), UPPER(value2), ..., UPPER(valuen))
- notin: Produces the SQL expression field NOT IN (value1, value2, ..., valuen)
- cinotin: Produces the SQL expression UPPER(field) NOT IN (UPPER(value1), UPPER(value2), ..., UPPER(valuen))
- bitwiseor: Produces the SQL expression field & value > 0 (useful for checking if any of a group of bits is set)
- bitwiseand: Produces the SQL expression field & value = value (useful for checking if all of a group of bits is set)
- bitwisenand: Produces the SQL expression field & value = 0 (useful for checking if none of a group of bits is set)
- exacttime: Produces the SQL expression field = value (enforces exact time match for date searches)
- length_lt: Searches based on the string length of the given field being less than value
- length_eq: Searches based on the string length of the given field being equal to value
- length_gt: Searches based on the string length of the given field being greater than value
- isnull: Produces the SQL expression field IS NULL
- notnull: Produces the SQL expression field IS NOT NULL
- isblank: Produces the SQL expression field IS NULL OR field = ''
- notblank: Produces the SQL expression field IS NOT NULL AND field <> ''

Can also use $$Today Wildcard in a query, here is some examples and explalination 

Wildcard value for midnight (12:00AM) of the current Date. Wildcards are useful for Saved Searches. If this value is passed in for any search value, it is replaced with the current date. The following suffixes can also be used to modify this date: [b/e][+/-][# of units]["h" (hour)|"d" (day)|"w" (week)|"m" (month)|"q" (quarter)|"y" (year)]

$$TODAY+1d would equal 12:00AM of the next day
$$TODAY-1d would equal 12:00AM of the previous day
$$TODAY+2w would equal 12:00AM of 2 weeks from today
$$TODAY+2m would equal 12:00AM of 2 months from today
$$TODAYb "the beginning of today" would equal 12:00AM today
$$TODAYe "the end of today" would equal 12:00AM tomorrow
$$TODAYbm "the beginning of the month" would equal 12:00AM of the first day of the month
$$TODAYe+1w "the end of next week" would equal 12:00AM Sunday following the Saturday of next week

